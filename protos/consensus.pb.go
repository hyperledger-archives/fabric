// Code generated by protoc-gen-go.
// source: consensus.proto
// DO NOT EDIT!

package protos

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type TransactionProposal_TxContentType int32

const (
	TransactionProposal_TRANSPARENT TransactionProposal_TxContentType = 0
	TransactionProposal_OPAQUE      TransactionProposal_TxContentType = 1
	TransactionProposal_COMMITMENT  TransactionProposal_TxContentType = 2
	TransactionProposal_NONE        TransactionProposal_TxContentType = 3
)

var TransactionProposal_TxContentType_name = map[int32]string{
	0: "TRANSPARENT",
	1: "OPAQUE",
	2: "COMMITMENT",
	3: "NONE",
}
var TransactionProposal_TxContentType_value = map[string]int32{
	"TRANSPARENT": 0,
	"OPAQUE":      1,
	"COMMITMENT":  2,
	"NONE":        3,
}

func (x TransactionProposal_TxContentType) String() string {
	return proto.EnumName(TransactionProposal_TxContentType_name, int32(x))
}

type ProposalResponse_TransactionInvalid int32

const (
	ProposalResponse_INCORRECT_STATE ProposalResponse_TransactionInvalid = 0
	ProposalResponse_STALE_VERSION   ProposalResponse_TransactionInvalid = 1
	ProposalResponse_REJECTED        ProposalResponse_TransactionInvalid = 2
)

var ProposalResponse_TransactionInvalid_name = map[int32]string{
	0: "INCORRECT_STATE",
	1: "STALE_VERSION",
	2: "REJECTED",
}
var ProposalResponse_TransactionInvalid_value = map[string]int32{
	"INCORRECT_STATE": 0,
	"STALE_VERSION":   1,
	"REJECTED":        2,
}

func (x ProposalResponse_TransactionInvalid) String() string {
	return proto.EnumName(ProposalResponse_TransactionInvalid_name, int32(x))
}

type TransactionProposal struct {
	SubmitingPeerID     string                            `protobuf:"bytes,1,opt,name=submitingPeerID" json:"submitingPeerID,omitempty"`
	ClientID            string                            `protobuf:"bytes,2,opt,name=clientID" json:"clientID,omitempty"`
	ChaincodeID         string                            `protobuf:"bytes,3,opt,name=chaincodeID" json:"chaincodeID,omitempty"`
	TxContentType       TransactionProposal_TxContentType `protobuf:"varint,4,opt,name=txContentType,enum=protos.TransactionProposal_TxContentType" json:"txContentType,omitempty"`
	TxContent           []byte                            `protobuf:"bytes,5,opt,name=txContent,proto3" json:"txContent,omitempty"`
	VersionDependencies *VerDep                           `protobuf:"bytes,6,opt,name=versionDependencies" json:"versionDependencies,omitempty"`
}

func (m *TransactionProposal) Reset()         { *m = TransactionProposal{} }
func (m *TransactionProposal) String() string { return proto.CompactTextString(m) }
func (*TransactionProposal) ProtoMessage()    {}

func (m *TransactionProposal) GetVersionDependencies() *VerDep {
	if m != nil {
		return m.VersionDependencies
	}
	return nil
}

type VerDep struct {
	ReadSet  []string    `protobuf:"bytes,1,rep,name=readSet" json:"readSet,omitempty"`
	WriteSet []*VarWrite `protobuf:"bytes,2,rep,name=writeSet" json:"writeSet,omitempty"`
}

func (m *VerDep) Reset()         { *m = VerDep{} }
func (m *VerDep) String() string { return proto.CompactTextString(m) }
func (*VerDep) ProtoMessage()    {}

func (m *VerDep) GetWriteSet() []*VarWrite {
	if m != nil {
		return m.WriteSet
	}
	return nil
}

type VarWrite struct {
	Name  string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Value []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *VarWrite) Reset()         { *m = VarWrite{} }
func (m *VarWrite) String() string { return proto.CompactTextString(m) }
func (*VarWrite) ProtoMessage()    {}

type ProposalResponse struct {
	// Types that are valid to be assigned to Response:
	//	*ProposalResponse_Valid
	//	*ProposalResponse_Invalid
	Response isProposalResponse_Response `protobuf_oneof:"Response"`
}

func (m *ProposalResponse) Reset()         { *m = ProposalResponse{} }
func (m *ProposalResponse) String() string { return proto.CompactTextString(m) }
func (*ProposalResponse) ProtoMessage()    {}

type isProposalResponse_Response interface {
	isProposalResponse_Response()
}

type ProposalResponse_Valid struct {
	Valid *TransactionValid `protobuf:"bytes,2,opt,name=valid,oneof"`
}
type ProposalResponse_Invalid struct {
	Invalid ProposalResponse_TransactionInvalid `protobuf:"varint,3,opt,name=invalid,enum=protos.ProposalResponse_TransactionInvalid,oneof"`
}

func (*ProposalResponse_Valid) isProposalResponse_Response()   {}
func (*ProposalResponse_Invalid) isProposalResponse_Response() {}

func (m *ProposalResponse) GetResponse() isProposalResponse_Response {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *ProposalResponse) GetValid() *TransactionValid {
	if x, ok := m.GetResponse().(*ProposalResponse_Valid); ok {
		return x.Valid
	}
	return nil
}

func (m *ProposalResponse) GetInvalid() ProposalResponse_TransactionInvalid {
	if x, ok := m.GetResponse().(*ProposalResponse_Invalid); ok {
		return x.Invalid
	}
	return ProposalResponse_INCORRECT_STATE
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ProposalResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), []interface{}) {
	return _ProposalResponse_OneofMarshaler, _ProposalResponse_OneofUnmarshaler, []interface{}{
		(*ProposalResponse_Valid)(nil),
		(*ProposalResponse_Invalid)(nil),
	}
}

func _ProposalResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ProposalResponse)
	// Response
	switch x := m.Response.(type) {
	case *ProposalResponse_Valid:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Valid); err != nil {
			return err
		}
	case *ProposalResponse_Invalid:
		b.EncodeVarint(3<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Invalid))
	case nil:
	default:
		return fmt.Errorf("ProposalResponse.Response has unexpected type %T", x)
	}
	return nil
}

func _ProposalResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ProposalResponse)
	switch tag {
	case 2: // Response.valid
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TransactionValid)
		err := b.DecodeMessage(msg)
		m.Response = &ProposalResponse_Valid{msg}
		return true, err
	case 3: // Response.invalid
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Response = &ProposalResponse_Invalid{ProposalResponse_TransactionInvalid(x)}
		return true, err
	default:
		return false, nil
	}
}

type TransactionValid struct {
	EndorsingSignature []byte `protobuf:"bytes,1,opt,name=endorsingSignature,proto3" json:"endorsingSignature,omitempty"`
}

func (m *TransactionValid) Reset()         { *m = TransactionValid{} }
func (m *TransactionValid) String() string { return proto.CompactTextString(m) }
func (*TransactionValid) ProtoMessage()    {}

type Broadcast struct {
	Proposal     *TransactionProposal `protobuf:"bytes,1,opt,name=proposal" json:"proposal,omitempty"`
	Endorsements [][]byte             `protobuf:"bytes,2,rep,name=endorsements,proto3" json:"endorsements,omitempty"`
}

func (m *Broadcast) Reset()         { *m = Broadcast{} }
func (m *Broadcast) String() string { return proto.CompactTextString(m) }
func (*Broadcast) ProtoMessage()    {}

func (m *Broadcast) GetProposal() *TransactionProposal {
	if m != nil {
		return m.Proposal
	}
	return nil
}

type Deliver struct {
	SeqNo    uint64     `protobuf:"varint,1,opt,name=seqNo" json:"seqNo,omitempty"`
	PrevHash []byte     `protobuf:"bytes,2,opt,name=prevHash,proto3" json:"prevHash,omitempty"`
	Blob     *Broadcast `protobuf:"bytes,3,opt,name=blob" json:"blob,omitempty"`
}

func (m *Deliver) Reset()         { *m = Deliver{} }
func (m *Deliver) String() string { return proto.CompactTextString(m) }
func (*Deliver) ProtoMessage()    {}

func (m *Deliver) GetBlob() *Broadcast {
	if m != nil {
		return m.Blob
	}
	return nil
}

type Result struct {
	Success bool `protobuf:"varint,1,opt,name=success" json:"success,omitempty"`
}

func (m *Result) Reset()         { *m = Result{} }
func (m *Result) String() string { return proto.CompactTextString(m) }
func (*Result) ProtoMessage()    {}

func init() {
	proto.RegisterEnum("protos.TransactionProposal_TxContentType", TransactionProposal_TxContentType_name, TransactionProposal_TxContentType_value)
	proto.RegisterEnum("protos.ProposalResponse_TransactionInvalid", ProposalResponse_TransactionInvalid_name, ProposalResponse_TransactionInvalid_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for Consensus service

type ConsensusClient interface {
	Chat(ctx context.Context, opts ...grpc.CallOption) (Consensus_ChatClient, error)
}

type consensusClient struct {
	cc *grpc.ClientConn
}

func NewConsensusClient(cc *grpc.ClientConn) ConsensusClient {
	return &consensusClient{cc}
}

func (c *consensusClient) Chat(ctx context.Context, opts ...grpc.CallOption) (Consensus_ChatClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Consensus_serviceDesc.Streams[0], c.cc, "/protos.Consensus/Chat", opts...)
	if err != nil {
		return nil, err
	}
	x := &consensusChatClient{stream}
	return x, nil
}

type Consensus_ChatClient interface {
	Send(*Broadcast) error
	Recv() (*Deliver, error)
	grpc.ClientStream
}

type consensusChatClient struct {
	grpc.ClientStream
}

func (x *consensusChatClient) Send(m *Broadcast) error {
	return x.ClientStream.SendMsg(m)
}

func (x *consensusChatClient) Recv() (*Deliver, error) {
	m := new(Deliver)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Consensus service

type ConsensusServer interface {
	Chat(Consensus_ChatServer) error
}

func RegisterConsensusServer(s *grpc.Server, srv ConsensusServer) {
	s.RegisterService(&_Consensus_serviceDesc, srv)
}

func _Consensus_Chat_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ConsensusServer).Chat(&consensusChatServer{stream})
}

type Consensus_ChatServer interface {
	Send(*Deliver) error
	Recv() (*Broadcast, error)
	grpc.ServerStream
}

type consensusChatServer struct {
	grpc.ServerStream
}

func (x *consensusChatServer) Send(m *Deliver) error {
	return x.ServerStream.SendMsg(m)
}

func (x *consensusChatServer) Recv() (*Broadcast, error) {
	m := new(Broadcast)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Consensus_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.Consensus",
	HandlerType: (*ConsensusServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Chat",
			Handler:       _Consensus_Chat_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
}

// Client API for Endorser service

type EndorserClient interface {
	Propose(ctx context.Context, in *TransactionProposal, opts ...grpc.CallOption) (*ProposalResponse, error)
}

type endorserClient struct {
	cc *grpc.ClientConn
}

func NewEndorserClient(cc *grpc.ClientConn) EndorserClient {
	return &endorserClient{cc}
}

func (c *endorserClient) Propose(ctx context.Context, in *TransactionProposal, opts ...grpc.CallOption) (*ProposalResponse, error) {
	out := new(ProposalResponse)
	err := grpc.Invoke(ctx, "/protos.Endorser/Propose", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Endorser service

type EndorserServer interface {
	Propose(context.Context, *TransactionProposal) (*ProposalResponse, error)
}

func RegisterEndorserServer(s *grpc.Server, srv EndorserServer) {
	s.RegisterService(&_Endorser_serviceDesc, srv)
}

func _Endorser_Propose_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(TransactionProposal)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(EndorserServer).Propose(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Endorser_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.Endorser",
	HandlerType: (*EndorserServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Propose",
			Handler:    _Endorser_Propose_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}
