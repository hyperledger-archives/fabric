// Code generated by protoc-gen-go.
// source: protos/ca.proto
// DO NOT EDIT!

/*
Package protos is a generated protocol buffer package.

It is generated from these files:
	protos/ca.proto

It has these top-level messages:
	CAStatus
	Empty
	Identity
	Token
	Hash
	PublicKey
	PrivateKey
	Signature
	RegisterUserReq
	ReadUserSetReq
	User
	UserSet
	ECertCreateReq
	ECertCreateResp
	ECertReadReq
	ECertRevokeReq
	ECertCRLReq
	TCertCreateReq
	TCertCreateResp
	TCertCreateSetReq
	TCertAttribute
	TCertCreateSetResp
	TCertReadReq
	TCertReadSetReq
	TCertReadSetsReq
	TCertRevokeReq
	TCertRevokeSetReq
	TCertCRLReq
	TLSCertCreateReq
	TLSCertCreateResp
	TLSCertReadReq
	TLSCertRevokeReq
	Cert
	TCert
	CertSet
	CertSets
	CertPair
*/
package protos

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "google/protobuf"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Public/private keys.
//
type CryptoType int32

const (
	CryptoType_ECDSA CryptoType = 0
	CryptoType_RSA   CryptoType = 1
	CryptoType_DSA   CryptoType = 2
)

var CryptoType_name = map[int32]string{
	0: "ECDSA",
	1: "RSA",
	2: "DSA",
}
var CryptoType_value = map[string]int32{
	"ECDSA": 0,
	"RSA":   1,
	"DSA":   2,
}

func (x CryptoType) String() string {
	return proto.EnumName(CryptoType_name, int32(x))
}

// User registration.
//
type Role int32

const (
	Role_NONE      Role = 0
	Role_CLIENT    Role = 1
	Role_PEER      Role = 2
	Role_VALIDATOR Role = 4
	Role_AUDITOR   Role = 8
	Role_ALL       Role = 65535
)

var Role_name = map[int32]string{
	0:     "NONE",
	1:     "CLIENT",
	2:     "PEER",
	4:     "VALIDATOR",
	8:     "AUDITOR",
	65535: "ALL",
}
var Role_value = map[string]int32{
	"NONE":      0,
	"CLIENT":    1,
	"PEER":      2,
	"VALIDATOR": 4,
	"AUDITOR":   8,
	"ALL":       65535,
}

func (x Role) String() string {
	return proto.EnumName(Role_name, int32(x))
}

type CAStatus_StatusCode int32

const (
	CAStatus_OK            CAStatus_StatusCode = 0
	CAStatus_UNKNOWN_ERROR CAStatus_StatusCode = 1
)

var CAStatus_StatusCode_name = map[int32]string{
	0: "OK",
	1: "UNKNOWN_ERROR",
}
var CAStatus_StatusCode_value = map[string]int32{
	"OK":            0,
	"UNKNOWN_ERROR": 1,
}

func (x CAStatus_StatusCode) String() string {
	return proto.EnumName(CAStatus_StatusCode_name, int32(x))
}

// Status codes shared by both CAs.
//
type CAStatus struct {
	Status CAStatus_StatusCode `protobuf:"varint,1,opt,name=status,enum=protos.CAStatus_StatusCode" json:"status,omitempty"`
}

func (m *CAStatus) Reset()         { *m = CAStatus{} }
func (m *CAStatus) String() string { return proto.CompactTextString(m) }
func (*CAStatus) ProtoMessage()    {}

// Empty message.
//
type Empty struct {
}

func (m *Empty) Reset()         { *m = Empty{} }
func (m *Empty) String() string { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()    {}

// Uniquely identifies a user towards either CA.
//
type Identity struct {
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *Identity) Reset()         { *m = Identity{} }
func (m *Identity) String() string { return proto.CompactTextString(m) }
func (*Identity) ProtoMessage()    {}

type Token struct {
	Tok []byte `protobuf:"bytes,1,opt,name=tok,proto3" json:"tok,omitempty"`
}

func (m *Token) Reset()         { *m = Token{} }
func (m *Token) String() string { return proto.CompactTextString(m) }
func (*Token) ProtoMessage()    {}

type Hash struct {
	Hash []byte `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
}

func (m *Hash) Reset()         { *m = Hash{} }
func (m *Hash) String() string { return proto.CompactTextString(m) }
func (*Hash) ProtoMessage()    {}

type PublicKey struct {
	Type CryptoType `protobuf:"varint,1,opt,name=type,enum=protos.CryptoType" json:"type,omitempty"`
	Key  []byte     `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *PublicKey) Reset()         { *m = PublicKey{} }
func (m *PublicKey) String() string { return proto.CompactTextString(m) }
func (*PublicKey) ProtoMessage()    {}

type PrivateKey struct {
	Type CryptoType `protobuf:"varint,1,opt,name=type,enum=protos.CryptoType" json:"type,omitempty"`
	Key  []byte     `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *PrivateKey) Reset()         { *m = PrivateKey{} }
func (m *PrivateKey) String() string { return proto.CompactTextString(m) }
func (*PrivateKey) ProtoMessage()    {}

// Signature.
//
type Signature struct {
	Type CryptoType `protobuf:"varint,1,opt,name=type,enum=protos.CryptoType" json:"type,omitempty"`
	R    []byte     `protobuf:"bytes,2,opt,name=r,proto3" json:"r,omitempty"`
	S    []byte     `protobuf:"bytes,3,opt,name=s,proto3" json:"s,omitempty"`
}

func (m *Signature) Reset()         { *m = Signature{} }
func (m *Signature) String() string { return proto.CompactTextString(m) }
func (*Signature) ProtoMessage()    {}

type RegisterUserReq struct {
	Id          *Identity `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Role        Role      `protobuf:"varint,2,opt,name=role,enum=protos.Role" json:"role,omitempty"`
	Account     string    `protobuf:"bytes,3,opt,name=account" json:"account,omitempty"`
	Affiliation string    `protobuf:"bytes,4,opt,name=affiliation" json:"affiliation,omitempty"`
}

func (m *RegisterUserReq) Reset()         { *m = RegisterUserReq{} }
func (m *RegisterUserReq) String() string { return proto.CompactTextString(m) }
func (*RegisterUserReq) ProtoMessage()    {}

func (m *RegisterUserReq) GetId() *Identity {
	if m != nil {
		return m.Id
	}
	return nil
}

type ReadUserSetReq struct {
	Req  *Identity  `protobuf:"bytes,1,opt,name=req" json:"req,omitempty"`
	Role Role       `protobuf:"varint,2,opt,name=role,enum=protos.Role" json:"role,omitempty"`
	Sig  *Signature `protobuf:"bytes,3,opt,name=sig" json:"sig,omitempty"`
}

func (m *ReadUserSetReq) Reset()         { *m = ReadUserSetReq{} }
func (m *ReadUserSetReq) String() string { return proto.CompactTextString(m) }
func (*ReadUserSetReq) ProtoMessage()    {}

func (m *ReadUserSetReq) GetReq() *Identity {
	if m != nil {
		return m.Req
	}
	return nil
}

func (m *ReadUserSetReq) GetSig() *Signature {
	if m != nil {
		return m.Sig
	}
	return nil
}

type User struct {
	Id   *Identity `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Role Role      `protobuf:"varint,2,opt,name=role,enum=protos.Role" json:"role,omitempty"`
}

func (m *User) Reset()         { *m = User{} }
func (m *User) String() string { return proto.CompactTextString(m) }
func (*User) ProtoMessage()    {}

func (m *User) GetId() *Identity {
	if m != nil {
		return m.Id
	}
	return nil
}

type UserSet struct {
	Users []*User `protobuf:"bytes,1,rep,name=users" json:"users,omitempty"`
}

func (m *UserSet) Reset()         { *m = UserSet{} }
func (m *UserSet) String() string { return proto.CompactTextString(m) }
func (*UserSet) ProtoMessage()    {}

func (m *UserSet) GetUsers() []*User {
	if m != nil {
		return m.Users
	}
	return nil
}

// Certificate requests.
//
type ECertCreateReq struct {
	Ts   *google_protobuf.Timestamp `protobuf:"bytes,1,opt,name=ts" json:"ts,omitempty"`
	Id   *Identity                  `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	Tok  *Token                     `protobuf:"bytes,3,opt,name=tok" json:"tok,omitempty"`
	Sign *PublicKey                 `protobuf:"bytes,4,opt,name=sign" json:"sign,omitempty"`
	Enc  *PublicKey                 `protobuf:"bytes,5,opt,name=enc" json:"enc,omitempty"`
	Sig  *Signature                 `protobuf:"bytes,6,opt,name=sig" json:"sig,omitempty"`
}

func (m *ECertCreateReq) Reset()         { *m = ECertCreateReq{} }
func (m *ECertCreateReq) String() string { return proto.CompactTextString(m) }
func (*ECertCreateReq) ProtoMessage()    {}

func (m *ECertCreateReq) GetTs() *google_protobuf.Timestamp {
	if m != nil {
		return m.Ts
	}
	return nil
}

func (m *ECertCreateReq) GetId() *Identity {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *ECertCreateReq) GetTok() *Token {
	if m != nil {
		return m.Tok
	}
	return nil
}

func (m *ECertCreateReq) GetSign() *PublicKey {
	if m != nil {
		return m.Sign
	}
	return nil
}

func (m *ECertCreateReq) GetEnc() *PublicKey {
	if m != nil {
		return m.Enc
	}
	return nil
}

func (m *ECertCreateReq) GetSig() *Signature {
	if m != nil {
		return m.Sig
	}
	return nil
}

type ECertCreateResp struct {
	Certs   *CertPair `protobuf:"bytes,1,opt,name=certs" json:"certs,omitempty"`
	Chain   *Token    `protobuf:"bytes,2,opt,name=chain" json:"chain,omitempty"`
	Pkchain []byte    `protobuf:"bytes,4,opt,name=pkchain,proto3" json:"pkchain,omitempty"`
	Tok     *Token    `protobuf:"bytes,3,opt,name=tok" json:"tok,omitempty"`
}

func (m *ECertCreateResp) Reset()         { *m = ECertCreateResp{} }
func (m *ECertCreateResp) String() string { return proto.CompactTextString(m) }
func (*ECertCreateResp) ProtoMessage()    {}

func (m *ECertCreateResp) GetCerts() *CertPair {
	if m != nil {
		return m.Certs
	}
	return nil
}

func (m *ECertCreateResp) GetChain() *Token {
	if m != nil {
		return m.Chain
	}
	return nil
}

func (m *ECertCreateResp) GetTok() *Token {
	if m != nil {
		return m.Tok
	}
	return nil
}

type ECertReadReq struct {
	Id *Identity `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *ECertReadReq) Reset()         { *m = ECertReadReq{} }
func (m *ECertReadReq) String() string { return proto.CompactTextString(m) }
func (*ECertReadReq) ProtoMessage()    {}

func (m *ECertReadReq) GetId() *Identity {
	if m != nil {
		return m.Id
	}
	return nil
}

type ECertRevokeReq struct {
	Id   *Identity  `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Cert *Cert      `protobuf:"bytes,2,opt,name=cert" json:"cert,omitempty"`
	Sig  *Signature `protobuf:"bytes,3,opt,name=sig" json:"sig,omitempty"`
}

func (m *ECertRevokeReq) Reset()         { *m = ECertRevokeReq{} }
func (m *ECertRevokeReq) String() string { return proto.CompactTextString(m) }
func (*ECertRevokeReq) ProtoMessage()    {}

func (m *ECertRevokeReq) GetId() *Identity {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *ECertRevokeReq) GetCert() *Cert {
	if m != nil {
		return m.Cert
	}
	return nil
}

func (m *ECertRevokeReq) GetSig() *Signature {
	if m != nil {
		return m.Sig
	}
	return nil
}

type ECertCRLReq struct {
	Id  *Identity  `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Sig *Signature `protobuf:"bytes,2,opt,name=sig" json:"sig,omitempty"`
}

func (m *ECertCRLReq) Reset()         { *m = ECertCRLReq{} }
func (m *ECertCRLReq) String() string { return proto.CompactTextString(m) }
func (*ECertCRLReq) ProtoMessage()    {}

func (m *ECertCRLReq) GetId() *Identity {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *ECertCRLReq) GetSig() *Signature {
	if m != nil {
		return m.Sig
	}
	return nil
}

type TCertCreateReq struct {
	Ts  *google_protobuf.Timestamp `protobuf:"bytes,1,opt,name=ts" json:"ts,omitempty"`
	Id  *Identity                  `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	Pub *PublicKey                 `protobuf:"bytes,3,opt,name=pub" json:"pub,omitempty"`
	Sig *Signature                 `protobuf:"bytes,4,opt,name=sig" json:"sig,omitempty"`
}

func (m *TCertCreateReq) Reset()         { *m = TCertCreateReq{} }
func (m *TCertCreateReq) String() string { return proto.CompactTextString(m) }
func (*TCertCreateReq) ProtoMessage()    {}

func (m *TCertCreateReq) GetTs() *google_protobuf.Timestamp {
	if m != nil {
		return m.Ts
	}
	return nil
}

func (m *TCertCreateReq) GetId() *Identity {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *TCertCreateReq) GetPub() *PublicKey {
	if m != nil {
		return m.Pub
	}
	return nil
}

func (m *TCertCreateReq) GetSig() *Signature {
	if m != nil {
		return m.Sig
	}
	return nil
}

type TCertCreateResp struct {
	Cert *Cert `protobuf:"bytes,1,opt,name=cert" json:"cert,omitempty"`
}

func (m *TCertCreateResp) Reset()         { *m = TCertCreateResp{} }
func (m *TCertCreateResp) String() string { return proto.CompactTextString(m) }
func (*TCertCreateResp) ProtoMessage()    {}

func (m *TCertCreateResp) GetCert() *Cert {
	if m != nil {
		return m.Cert
	}
	return nil
}

type TCertCreateSetReq struct {
	Ts         *google_protobuf.Timestamp `protobuf:"bytes,1,opt,name=ts" json:"ts,omitempty"`
	Id         *Identity                  `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	Num        uint32                     `protobuf:"varint,3,opt,name=num" json:"num,omitempty"`
	Attributes []*TCertAttribute          `protobuf:"bytes,4,rep,name=attributes" json:"attributes,omitempty"`
	Sig        *Signature                 `protobuf:"bytes,5,opt,name=sig" json:"sig,omitempty"`
}

func (m *TCertCreateSetReq) Reset()         { *m = TCertCreateSetReq{} }
func (m *TCertCreateSetReq) String() string { return proto.CompactTextString(m) }
func (*TCertCreateSetReq) ProtoMessage()    {}

func (m *TCertCreateSetReq) GetTs() *google_protobuf.Timestamp {
	if m != nil {
		return m.Ts
	}
	return nil
}

func (m *TCertCreateSetReq) GetId() *Identity {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *TCertCreateSetReq) GetAttributes() []*TCertAttribute {
	if m != nil {
		return m.Attributes
	}
	return nil
}

func (m *TCertCreateSetReq) GetSig() *Signature {
	if m != nil {
		return m.Sig
	}
	return nil
}

type TCertAttribute struct {
	AttributeName  string `protobuf:"bytes,1,opt,name=attributeName" json:"attributeName,omitempty"`
	AttributeValue string `protobuf:"bytes,2,opt,name=attributeValue" json:"attributeValue,omitempty"`
}

func (m *TCertAttribute) Reset()         { *m = TCertAttribute{} }
func (m *TCertAttribute) String() string { return proto.CompactTextString(m) }
func (*TCertAttribute) ProtoMessage()    {}

type TCertCreateSetResp struct {
	Certs *CertSet `protobuf:"bytes,1,opt,name=certs" json:"certs,omitempty"`
}

func (m *TCertCreateSetResp) Reset()         { *m = TCertCreateSetResp{} }
func (m *TCertCreateSetResp) String() string { return proto.CompactTextString(m) }
func (*TCertCreateSetResp) ProtoMessage()    {}

func (m *TCertCreateSetResp) GetCerts() *CertSet {
	if m != nil {
		return m.Certs
	}
	return nil
}

type TCertReadReq struct {
	Ts   *google_protobuf.Timestamp `protobuf:"bytes,1,opt,name=ts" json:"ts,omitempty"`
	Hash *Hash                      `protobuf:"bytes,2,opt,name=hash" json:"hash,omitempty"`
	Req  *Identity                  `protobuf:"bytes,3,opt,name=req" json:"req,omitempty"`
	Id   *Identity                  `protobuf:"bytes,4,opt,name=id" json:"id,omitempty"`
	Sig  *Signature                 `protobuf:"bytes,5,opt,name=sig" json:"sig,omitempty"`
}

func (m *TCertReadReq) Reset()         { *m = TCertReadReq{} }
func (m *TCertReadReq) String() string { return proto.CompactTextString(m) }
func (*TCertReadReq) ProtoMessage()    {}

func (m *TCertReadReq) GetTs() *google_protobuf.Timestamp {
	if m != nil {
		return m.Ts
	}
	return nil
}

func (m *TCertReadReq) GetHash() *Hash {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *TCertReadReq) GetReq() *Identity {
	if m != nil {
		return m.Req
	}
	return nil
}

func (m *TCertReadReq) GetId() *Identity {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *TCertReadReq) GetSig() *Signature {
	if m != nil {
		return m.Sig
	}
	return nil
}

type TCertReadSetReq struct {
	Ts  *google_protobuf.Timestamp `protobuf:"bytes,1,opt,name=ts" json:"ts,omitempty"`
	Req *Identity                  `protobuf:"bytes,2,opt,name=req" json:"req,omitempty"`
	Id  *Identity                  `protobuf:"bytes,3,opt,name=id" json:"id,omitempty"`
	Num uint32                     `protobuf:"varint,4,opt,name=num" json:"num,omitempty"`
	Sig *Signature                 `protobuf:"bytes,5,opt,name=sig" json:"sig,omitempty"`
}

func (m *TCertReadSetReq) Reset()         { *m = TCertReadSetReq{} }
func (m *TCertReadSetReq) String() string { return proto.CompactTextString(m) }
func (*TCertReadSetReq) ProtoMessage()    {}

func (m *TCertReadSetReq) GetTs() *google_protobuf.Timestamp {
	if m != nil {
		return m.Ts
	}
	return nil
}

func (m *TCertReadSetReq) GetReq() *Identity {
	if m != nil {
		return m.Req
	}
	return nil
}

func (m *TCertReadSetReq) GetId() *Identity {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *TCertReadSetReq) GetSig() *Signature {
	if m != nil {
		return m.Sig
	}
	return nil
}

type TCertReadSetsReq struct {
	Begin *google_protobuf.Timestamp `protobuf:"bytes,1,opt,name=begin" json:"begin,omitempty"`
	End   *google_protobuf.Timestamp `protobuf:"bytes,2,opt,name=end" json:"end,omitempty"`
	Req   *Identity                  `protobuf:"bytes,3,opt,name=req" json:"req,omitempty"`
	Role  Role                       `protobuf:"varint,4,opt,name=role,enum=protos.Role" json:"role,omitempty"`
	Sig   *Signature                 `protobuf:"bytes,5,opt,name=sig" json:"sig,omitempty"`
}

func (m *TCertReadSetsReq) Reset()         { *m = TCertReadSetsReq{} }
func (m *TCertReadSetsReq) String() string { return proto.CompactTextString(m) }
func (*TCertReadSetsReq) ProtoMessage()    {}

func (m *TCertReadSetsReq) GetBegin() *google_protobuf.Timestamp {
	if m != nil {
		return m.Begin
	}
	return nil
}

func (m *TCertReadSetsReq) GetEnd() *google_protobuf.Timestamp {
	if m != nil {
		return m.End
	}
	return nil
}

func (m *TCertReadSetsReq) GetReq() *Identity {
	if m != nil {
		return m.Req
	}
	return nil
}

func (m *TCertReadSetsReq) GetSig() *Signature {
	if m != nil {
		return m.Sig
	}
	return nil
}

type TCertRevokeReq struct {
	Id   *Identity  `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Cert *Cert      `protobuf:"bytes,2,opt,name=cert" json:"cert,omitempty"`
	Sig  *Signature `protobuf:"bytes,3,opt,name=sig" json:"sig,omitempty"`
}

func (m *TCertRevokeReq) Reset()         { *m = TCertRevokeReq{} }
func (m *TCertRevokeReq) String() string { return proto.CompactTextString(m) }
func (*TCertRevokeReq) ProtoMessage()    {}

func (m *TCertRevokeReq) GetId() *Identity {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *TCertRevokeReq) GetCert() *Cert {
	if m != nil {
		return m.Cert
	}
	return nil
}

func (m *TCertRevokeReq) GetSig() *Signature {
	if m != nil {
		return m.Sig
	}
	return nil
}

type TCertRevokeSetReq struct {
	Id  *Identity                  `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Ts  *google_protobuf.Timestamp `protobuf:"bytes,2,opt,name=ts" json:"ts,omitempty"`
	Sig *Signature                 `protobuf:"bytes,3,opt,name=sig" json:"sig,omitempty"`
}

func (m *TCertRevokeSetReq) Reset()         { *m = TCertRevokeSetReq{} }
func (m *TCertRevokeSetReq) String() string { return proto.CompactTextString(m) }
func (*TCertRevokeSetReq) ProtoMessage()    {}

func (m *TCertRevokeSetReq) GetId() *Identity {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *TCertRevokeSetReq) GetTs() *google_protobuf.Timestamp {
	if m != nil {
		return m.Ts
	}
	return nil
}

func (m *TCertRevokeSetReq) GetSig() *Signature {
	if m != nil {
		return m.Sig
	}
	return nil
}

type TCertCRLReq struct {
	Id  *Identity  `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Sig *Signature `protobuf:"bytes,2,opt,name=sig" json:"sig,omitempty"`
}

func (m *TCertCRLReq) Reset()         { *m = TCertCRLReq{} }
func (m *TCertCRLReq) String() string { return proto.CompactTextString(m) }
func (*TCertCRLReq) ProtoMessage()    {}

func (m *TCertCRLReq) GetId() *Identity {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *TCertCRLReq) GetSig() *Signature {
	if m != nil {
		return m.Sig
	}
	return nil
}

type TLSCertCreateReq struct {
	Ts  *google_protobuf.Timestamp `protobuf:"bytes,1,opt,name=ts" json:"ts,omitempty"`
	Id  *Identity                  `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	Pub *PublicKey                 `protobuf:"bytes,3,opt,name=pub" json:"pub,omitempty"`
	Sig *Signature                 `protobuf:"bytes,4,opt,name=sig" json:"sig,omitempty"`
}

func (m *TLSCertCreateReq) Reset()         { *m = TLSCertCreateReq{} }
func (m *TLSCertCreateReq) String() string { return proto.CompactTextString(m) }
func (*TLSCertCreateReq) ProtoMessage()    {}

func (m *TLSCertCreateReq) GetTs() *google_protobuf.Timestamp {
	if m != nil {
		return m.Ts
	}
	return nil
}

func (m *TLSCertCreateReq) GetId() *Identity {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *TLSCertCreateReq) GetPub() *PublicKey {
	if m != nil {
		return m.Pub
	}
	return nil
}

func (m *TLSCertCreateReq) GetSig() *Signature {
	if m != nil {
		return m.Sig
	}
	return nil
}

type TLSCertCreateResp struct {
	Cert     *Cert `protobuf:"bytes,1,opt,name=cert" json:"cert,omitempty"`
	RootCert *Cert `protobuf:"bytes,2,opt,name=rootCert" json:"rootCert,omitempty"`
}

func (m *TLSCertCreateResp) Reset()         { *m = TLSCertCreateResp{} }
func (m *TLSCertCreateResp) String() string { return proto.CompactTextString(m) }
func (*TLSCertCreateResp) ProtoMessage()    {}

func (m *TLSCertCreateResp) GetCert() *Cert {
	if m != nil {
		return m.Cert
	}
	return nil
}

func (m *TLSCertCreateResp) GetRootCert() *Cert {
	if m != nil {
		return m.RootCert
	}
	return nil
}

type TLSCertReadReq struct {
	Id *Identity `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *TLSCertReadReq) Reset()         { *m = TLSCertReadReq{} }
func (m *TLSCertReadReq) String() string { return proto.CompactTextString(m) }
func (*TLSCertReadReq) ProtoMessage()    {}

func (m *TLSCertReadReq) GetId() *Identity {
	if m != nil {
		return m.Id
	}
	return nil
}

type TLSCertRevokeReq struct {
	Id   *Identity  `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Cert *Cert      `protobuf:"bytes,2,opt,name=cert" json:"cert,omitempty"`
	Sig  *Signature `protobuf:"bytes,3,opt,name=sig" json:"sig,omitempty"`
}

func (m *TLSCertRevokeReq) Reset()         { *m = TLSCertRevokeReq{} }
func (m *TLSCertRevokeReq) String() string { return proto.CompactTextString(m) }
func (*TLSCertRevokeReq) ProtoMessage()    {}

func (m *TLSCertRevokeReq) GetId() *Identity {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *TLSCertRevokeReq) GetCert() *Cert {
	if m != nil {
		return m.Cert
	}
	return nil
}

func (m *TLSCertRevokeReq) GetSig() *Signature {
	if m != nil {
		return m.Sig
	}
	return nil
}

// Certificate issued by either the ECA or TCA.
//
type Cert struct {
	Cert []byte `protobuf:"bytes,1,opt,name=cert,proto3" json:"cert,omitempty"`
}

func (m *Cert) Reset()         { *m = Cert{} }
func (m *Cert) String() string { return proto.CompactTextString(m) }
func (*Cert) ProtoMessage()    {}

// TCert
//
type TCert struct {
	Cert []byte            `protobuf:"bytes,1,opt,name=cert,proto3" json:"cert,omitempty"`
	Keys map[string][]byte `protobuf:"bytes,2,rep,name=keys" json:"keys,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *TCert) Reset()         { *m = TCert{} }
func (m *TCert) String() string { return proto.CompactTextString(m) }
func (*TCert) ProtoMessage()    {}

func (m *TCert) GetKeys() map[string][]byte {
	if m != nil {
		return m.Keys
	}
	return nil
}

type CertSet struct {
	Ts    *google_protobuf.Timestamp `protobuf:"bytes,1,opt,name=ts" json:"ts,omitempty"`
	Id    *Identity                  `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	Key   []byte                     `protobuf:"bytes,3,opt,name=key,proto3" json:"key,omitempty"`
	Certs []*TCert                   `protobuf:"bytes,4,rep,name=certs" json:"certs,omitempty"`
}

func (m *CertSet) Reset()         { *m = CertSet{} }
func (m *CertSet) String() string { return proto.CompactTextString(m) }
func (*CertSet) ProtoMessage()    {}

func (m *CertSet) GetTs() *google_protobuf.Timestamp {
	if m != nil {
		return m.Ts
	}
	return nil
}

func (m *CertSet) GetId() *Identity {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *CertSet) GetCerts() []*TCert {
	if m != nil {
		return m.Certs
	}
	return nil
}

type CertSets struct {
	Sets []*CertSet `protobuf:"bytes,1,rep,name=sets" json:"sets,omitempty"`
}

func (m *CertSets) Reset()         { *m = CertSets{} }
func (m *CertSets) String() string { return proto.CompactTextString(m) }
func (*CertSets) ProtoMessage()    {}

func (m *CertSets) GetSets() []*CertSet {
	if m != nil {
		return m.Sets
	}
	return nil
}

type CertPair struct {
	Sign []byte `protobuf:"bytes,1,opt,name=sign,proto3" json:"sign,omitempty"`
	Enc  []byte `protobuf:"bytes,2,opt,name=enc,proto3" json:"enc,omitempty"`
}

func (m *CertPair) Reset()         { *m = CertPair{} }
func (m *CertPair) String() string { return proto.CompactTextString(m) }
func (*CertPair) ProtoMessage()    {}

func init() {
	proto.RegisterEnum("protos.CryptoType", CryptoType_name, CryptoType_value)
	proto.RegisterEnum("protos.Role", Role_name, Role_value)
	proto.RegisterEnum("protos.CAStatus_StatusCode", CAStatus_StatusCode_name, CAStatus_StatusCode_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for ECAP service

type ECAPClient interface {
	ReadCACertificate(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Cert, error)
	CreateCertificatePair(ctx context.Context, in *ECertCreateReq, opts ...grpc.CallOption) (*ECertCreateResp, error)
	ReadCertificatePair(ctx context.Context, in *ECertReadReq, opts ...grpc.CallOption) (*CertPair, error)
	ReadCertificateByHash(ctx context.Context, in *Hash, opts ...grpc.CallOption) (*Cert, error)
	RevokeCertificatePair(ctx context.Context, in *ECertRevokeReq, opts ...grpc.CallOption) (*CAStatus, error)
}

type eCAPClient struct {
	cc *grpc.ClientConn
}

func NewECAPClient(cc *grpc.ClientConn) ECAPClient {
	return &eCAPClient{cc}
}

func (c *eCAPClient) ReadCACertificate(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Cert, error) {
	out := new(Cert)
	err := grpc.Invoke(ctx, "/protos.ECAP/ReadCACertificate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eCAPClient) CreateCertificatePair(ctx context.Context, in *ECertCreateReq, opts ...grpc.CallOption) (*ECertCreateResp, error) {
	out := new(ECertCreateResp)
	err := grpc.Invoke(ctx, "/protos.ECAP/CreateCertificatePair", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eCAPClient) ReadCertificatePair(ctx context.Context, in *ECertReadReq, opts ...grpc.CallOption) (*CertPair, error) {
	out := new(CertPair)
	err := grpc.Invoke(ctx, "/protos.ECAP/ReadCertificatePair", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eCAPClient) ReadCertificateByHash(ctx context.Context, in *Hash, opts ...grpc.CallOption) (*Cert, error) {
	out := new(Cert)
	err := grpc.Invoke(ctx, "/protos.ECAP/ReadCertificateByHash", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eCAPClient) RevokeCertificatePair(ctx context.Context, in *ECertRevokeReq, opts ...grpc.CallOption) (*CAStatus, error) {
	out := new(CAStatus)
	err := grpc.Invoke(ctx, "/protos.ECAP/RevokeCertificatePair", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ECAP service

type ECAPServer interface {
	ReadCACertificate(context.Context, *Empty) (*Cert, error)
	CreateCertificatePair(context.Context, *ECertCreateReq) (*ECertCreateResp, error)
	ReadCertificatePair(context.Context, *ECertReadReq) (*CertPair, error)
	ReadCertificateByHash(context.Context, *Hash) (*Cert, error)
	RevokeCertificatePair(context.Context, *ECertRevokeReq) (*CAStatus, error)
}

func RegisterECAPServer(s *grpc.Server, srv ECAPServer) {
	s.RegisterService(&_ECAP_serviceDesc, srv)
}

func _ECAP_ReadCACertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ECAPServer).ReadCACertificate(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ECAP_CreateCertificatePair_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ECertCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ECAPServer).CreateCertificatePair(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ECAP_ReadCertificatePair_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ECertReadReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ECAPServer).ReadCertificatePair(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ECAP_ReadCertificateByHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(Hash)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ECAPServer).ReadCertificateByHash(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ECAP_RevokeCertificatePair_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ECertRevokeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ECAPServer).RevokeCertificatePair(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _ECAP_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.ECAP",
	HandlerType: (*ECAPServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReadCACertificate",
			Handler:    _ECAP_ReadCACertificate_Handler,
		},
		{
			MethodName: "CreateCertificatePair",
			Handler:    _ECAP_CreateCertificatePair_Handler,
		},
		{
			MethodName: "ReadCertificatePair",
			Handler:    _ECAP_ReadCertificatePair_Handler,
		},
		{
			MethodName: "ReadCertificateByHash",
			Handler:    _ECAP_ReadCertificateByHash_Handler,
		},
		{
			MethodName: "RevokeCertificatePair",
			Handler:    _ECAP_RevokeCertificatePair_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for ECAA service

type ECAAClient interface {
	RegisterUser(ctx context.Context, in *RegisterUserReq, opts ...grpc.CallOption) (*Token, error)
	ReadUserSet(ctx context.Context, in *ReadUserSetReq, opts ...grpc.CallOption) (*UserSet, error)
	RevokeCertificate(ctx context.Context, in *ECertRevokeReq, opts ...grpc.CallOption) (*CAStatus, error)
	PublishCRL(ctx context.Context, in *ECertCRLReq, opts ...grpc.CallOption) (*CAStatus, error)
}

type eCAAClient struct {
	cc *grpc.ClientConn
}

func NewECAAClient(cc *grpc.ClientConn) ECAAClient {
	return &eCAAClient{cc}
}

func (c *eCAAClient) RegisterUser(ctx context.Context, in *RegisterUserReq, opts ...grpc.CallOption) (*Token, error) {
	out := new(Token)
	err := grpc.Invoke(ctx, "/protos.ECAA/RegisterUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eCAAClient) ReadUserSet(ctx context.Context, in *ReadUserSetReq, opts ...grpc.CallOption) (*UserSet, error) {
	out := new(UserSet)
	err := grpc.Invoke(ctx, "/protos.ECAA/ReadUserSet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eCAAClient) RevokeCertificate(ctx context.Context, in *ECertRevokeReq, opts ...grpc.CallOption) (*CAStatus, error) {
	out := new(CAStatus)
	err := grpc.Invoke(ctx, "/protos.ECAA/RevokeCertificate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eCAAClient) PublishCRL(ctx context.Context, in *ECertCRLReq, opts ...grpc.CallOption) (*CAStatus, error) {
	out := new(CAStatus)
	err := grpc.Invoke(ctx, "/protos.ECAA/PublishCRL", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ECAA service

type ECAAServer interface {
	RegisterUser(context.Context, *RegisterUserReq) (*Token, error)
	ReadUserSet(context.Context, *ReadUserSetReq) (*UserSet, error)
	RevokeCertificate(context.Context, *ECertRevokeReq) (*CAStatus, error)
	PublishCRL(context.Context, *ECertCRLReq) (*CAStatus, error)
}

func RegisterECAAServer(s *grpc.Server, srv ECAAServer) {
	s.RegisterService(&_ECAA_serviceDesc, srv)
}

func _ECAA_RegisterUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RegisterUserReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ECAAServer).RegisterUser(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ECAA_ReadUserSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ReadUserSetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ECAAServer).ReadUserSet(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ECAA_RevokeCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ECertRevokeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ECAAServer).RevokeCertificate(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ECAA_PublishCRL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ECertCRLReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ECAAServer).PublishCRL(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _ECAA_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.ECAA",
	HandlerType: (*ECAAServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterUser",
			Handler:    _ECAA_RegisterUser_Handler,
		},
		{
			MethodName: "ReadUserSet",
			Handler:    _ECAA_ReadUserSet_Handler,
		},
		{
			MethodName: "RevokeCertificate",
			Handler:    _ECAA_RevokeCertificate_Handler,
		},
		{
			MethodName: "PublishCRL",
			Handler:    _ECAA_PublishCRL_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for TCAP service

type TCAPClient interface {
	ReadCACertificate(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Cert, error)
	CreateCertificateSet(ctx context.Context, in *TCertCreateSetReq, opts ...grpc.CallOption) (*TCertCreateSetResp, error)
	ReadCertificate(ctx context.Context, in *TCertReadReq, opts ...grpc.CallOption) (*Cert, error)
	ReadCertificateSet(ctx context.Context, in *TCertReadSetReq, opts ...grpc.CallOption) (*CertSet, error)
	RevokeCertificate(ctx context.Context, in *TCertRevokeReq, opts ...grpc.CallOption) (*CAStatus, error)
	RevokeCertificateSet(ctx context.Context, in *TCertRevokeSetReq, opts ...grpc.CallOption) (*CAStatus, error)
}

type tCAPClient struct {
	cc *grpc.ClientConn
}

func NewTCAPClient(cc *grpc.ClientConn) TCAPClient {
	return &tCAPClient{cc}
}

func (c *tCAPClient) ReadCACertificate(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Cert, error) {
	out := new(Cert)
	err := grpc.Invoke(ctx, "/protos.TCAP/ReadCACertificate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tCAPClient) CreateCertificateSet(ctx context.Context, in *TCertCreateSetReq, opts ...grpc.CallOption) (*TCertCreateSetResp, error) {
	out := new(TCertCreateSetResp)
	err := grpc.Invoke(ctx, "/protos.TCAP/CreateCertificateSet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tCAPClient) ReadCertificate(ctx context.Context, in *TCertReadReq, opts ...grpc.CallOption) (*Cert, error) {
	out := new(Cert)
	err := grpc.Invoke(ctx, "/protos.TCAP/ReadCertificate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tCAPClient) ReadCertificateSet(ctx context.Context, in *TCertReadSetReq, opts ...grpc.CallOption) (*CertSet, error) {
	out := new(CertSet)
	err := grpc.Invoke(ctx, "/protos.TCAP/ReadCertificateSet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tCAPClient) RevokeCertificate(ctx context.Context, in *TCertRevokeReq, opts ...grpc.CallOption) (*CAStatus, error) {
	out := new(CAStatus)
	err := grpc.Invoke(ctx, "/protos.TCAP/RevokeCertificate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tCAPClient) RevokeCertificateSet(ctx context.Context, in *TCertRevokeSetReq, opts ...grpc.CallOption) (*CAStatus, error) {
	out := new(CAStatus)
	err := grpc.Invoke(ctx, "/protos.TCAP/RevokeCertificateSet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for TCAP service

type TCAPServer interface {
	ReadCACertificate(context.Context, *Empty) (*Cert, error)
	CreateCertificateSet(context.Context, *TCertCreateSetReq) (*TCertCreateSetResp, error)
	ReadCertificate(context.Context, *TCertReadReq) (*Cert, error)
	ReadCertificateSet(context.Context, *TCertReadSetReq) (*CertSet, error)
	RevokeCertificate(context.Context, *TCertRevokeReq) (*CAStatus, error)
	RevokeCertificateSet(context.Context, *TCertRevokeSetReq) (*CAStatus, error)
}

func RegisterTCAPServer(s *grpc.Server, srv TCAPServer) {
	s.RegisterService(&_TCAP_serviceDesc, srv)
}

func _TCAP_ReadCACertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(TCAPServer).ReadCACertificate(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _TCAP_CreateCertificateSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(TCertCreateSetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(TCAPServer).CreateCertificateSet(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _TCAP_ReadCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(TCertReadReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(TCAPServer).ReadCertificate(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _TCAP_ReadCertificateSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(TCertReadSetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(TCAPServer).ReadCertificateSet(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _TCAP_RevokeCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(TCertRevokeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(TCAPServer).RevokeCertificate(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _TCAP_RevokeCertificateSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(TCertRevokeSetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(TCAPServer).RevokeCertificateSet(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _TCAP_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.TCAP",
	HandlerType: (*TCAPServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReadCACertificate",
			Handler:    _TCAP_ReadCACertificate_Handler,
		},
		{
			MethodName: "CreateCertificateSet",
			Handler:    _TCAP_CreateCertificateSet_Handler,
		},
		{
			MethodName: "ReadCertificate",
			Handler:    _TCAP_ReadCertificate_Handler,
		},
		{
			MethodName: "ReadCertificateSet",
			Handler:    _TCAP_ReadCertificateSet_Handler,
		},
		{
			MethodName: "RevokeCertificate",
			Handler:    _TCAP_RevokeCertificate_Handler,
		},
		{
			MethodName: "RevokeCertificateSet",
			Handler:    _TCAP_RevokeCertificateSet_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for TCAA service

type TCAAClient interface {
	ReadCertificateSets(ctx context.Context, in *TCertReadSetsReq, opts ...grpc.CallOption) (*CertSets, error)
	RevokeCertificate(ctx context.Context, in *TCertRevokeReq, opts ...grpc.CallOption) (*CAStatus, error)
	RevokeCertificateSet(ctx context.Context, in *TCertRevokeSetReq, opts ...grpc.CallOption) (*CAStatus, error)
	PublishCRL(ctx context.Context, in *TCertCRLReq, opts ...grpc.CallOption) (*CAStatus, error)
}

type tCAAClient struct {
	cc *grpc.ClientConn
}

func NewTCAAClient(cc *grpc.ClientConn) TCAAClient {
	return &tCAAClient{cc}
}

func (c *tCAAClient) ReadCertificateSets(ctx context.Context, in *TCertReadSetsReq, opts ...grpc.CallOption) (*CertSets, error) {
	out := new(CertSets)
	err := grpc.Invoke(ctx, "/protos.TCAA/ReadCertificateSets", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tCAAClient) RevokeCertificate(ctx context.Context, in *TCertRevokeReq, opts ...grpc.CallOption) (*CAStatus, error) {
	out := new(CAStatus)
	err := grpc.Invoke(ctx, "/protos.TCAA/RevokeCertificate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tCAAClient) RevokeCertificateSet(ctx context.Context, in *TCertRevokeSetReq, opts ...grpc.CallOption) (*CAStatus, error) {
	out := new(CAStatus)
	err := grpc.Invoke(ctx, "/protos.TCAA/RevokeCertificateSet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tCAAClient) PublishCRL(ctx context.Context, in *TCertCRLReq, opts ...grpc.CallOption) (*CAStatus, error) {
	out := new(CAStatus)
	err := grpc.Invoke(ctx, "/protos.TCAA/PublishCRL", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for TCAA service

type TCAAServer interface {
	ReadCertificateSets(context.Context, *TCertReadSetsReq) (*CertSets, error)
	RevokeCertificate(context.Context, *TCertRevokeReq) (*CAStatus, error)
	RevokeCertificateSet(context.Context, *TCertRevokeSetReq) (*CAStatus, error)
	PublishCRL(context.Context, *TCertCRLReq) (*CAStatus, error)
}

func RegisterTCAAServer(s *grpc.Server, srv TCAAServer) {
	s.RegisterService(&_TCAA_serviceDesc, srv)
}

func _TCAA_ReadCertificateSets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(TCertReadSetsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(TCAAServer).ReadCertificateSets(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _TCAA_RevokeCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(TCertRevokeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(TCAAServer).RevokeCertificate(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _TCAA_RevokeCertificateSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(TCertRevokeSetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(TCAAServer).RevokeCertificateSet(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _TCAA_PublishCRL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(TCertCRLReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(TCAAServer).PublishCRL(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _TCAA_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.TCAA",
	HandlerType: (*TCAAServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReadCertificateSets",
			Handler:    _TCAA_ReadCertificateSets_Handler,
		},
		{
			MethodName: "RevokeCertificate",
			Handler:    _TCAA_RevokeCertificate_Handler,
		},
		{
			MethodName: "RevokeCertificateSet",
			Handler:    _TCAA_RevokeCertificateSet_Handler,
		},
		{
			MethodName: "PublishCRL",
			Handler:    _TCAA_PublishCRL_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for TLSCAP service

type TLSCAPClient interface {
	ReadCACertificate(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Cert, error)
	CreateCertificate(ctx context.Context, in *TLSCertCreateReq, opts ...grpc.CallOption) (*TLSCertCreateResp, error)
	ReadCertificate(ctx context.Context, in *TLSCertReadReq, opts ...grpc.CallOption) (*Cert, error)
	RevokeCertificate(ctx context.Context, in *TLSCertRevokeReq, opts ...grpc.CallOption) (*CAStatus, error)
}

type tLSCAPClient struct {
	cc *grpc.ClientConn
}

func NewTLSCAPClient(cc *grpc.ClientConn) TLSCAPClient {
	return &tLSCAPClient{cc}
}

func (c *tLSCAPClient) ReadCACertificate(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Cert, error) {
	out := new(Cert)
	err := grpc.Invoke(ctx, "/protos.TLSCAP/ReadCACertificate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tLSCAPClient) CreateCertificate(ctx context.Context, in *TLSCertCreateReq, opts ...grpc.CallOption) (*TLSCertCreateResp, error) {
	out := new(TLSCertCreateResp)
	err := grpc.Invoke(ctx, "/protos.TLSCAP/CreateCertificate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tLSCAPClient) ReadCertificate(ctx context.Context, in *TLSCertReadReq, opts ...grpc.CallOption) (*Cert, error) {
	out := new(Cert)
	err := grpc.Invoke(ctx, "/protos.TLSCAP/ReadCertificate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tLSCAPClient) RevokeCertificate(ctx context.Context, in *TLSCertRevokeReq, opts ...grpc.CallOption) (*CAStatus, error) {
	out := new(CAStatus)
	err := grpc.Invoke(ctx, "/protos.TLSCAP/RevokeCertificate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for TLSCAP service

type TLSCAPServer interface {
	ReadCACertificate(context.Context, *Empty) (*Cert, error)
	CreateCertificate(context.Context, *TLSCertCreateReq) (*TLSCertCreateResp, error)
	ReadCertificate(context.Context, *TLSCertReadReq) (*Cert, error)
	RevokeCertificate(context.Context, *TLSCertRevokeReq) (*CAStatus, error)
}

func RegisterTLSCAPServer(s *grpc.Server, srv TLSCAPServer) {
	s.RegisterService(&_TLSCAP_serviceDesc, srv)
}

func _TLSCAP_ReadCACertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(TLSCAPServer).ReadCACertificate(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _TLSCAP_CreateCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(TLSCertCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(TLSCAPServer).CreateCertificate(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _TLSCAP_ReadCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(TLSCertReadReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(TLSCAPServer).ReadCertificate(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _TLSCAP_RevokeCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(TLSCertRevokeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(TLSCAPServer).RevokeCertificate(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _TLSCAP_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.TLSCAP",
	HandlerType: (*TLSCAPServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReadCACertificate",
			Handler:    _TLSCAP_ReadCACertificate_Handler,
		},
		{
			MethodName: "CreateCertificate",
			Handler:    _TLSCAP_CreateCertificate_Handler,
		},
		{
			MethodName: "ReadCertificate",
			Handler:    _TLSCAP_ReadCertificate_Handler,
		},
		{
			MethodName: "RevokeCertificate",
			Handler:    _TLSCAP_RevokeCertificate_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for TLSCAA service

type TLSCAAClient interface {
	RevokeCertificate(ctx context.Context, in *TLSCertRevokeReq, opts ...grpc.CallOption) (*CAStatus, error)
}

type tLSCAAClient struct {
	cc *grpc.ClientConn
}

func NewTLSCAAClient(cc *grpc.ClientConn) TLSCAAClient {
	return &tLSCAAClient{cc}
}

func (c *tLSCAAClient) RevokeCertificate(ctx context.Context, in *TLSCertRevokeReq, opts ...grpc.CallOption) (*CAStatus, error) {
	out := new(CAStatus)
	err := grpc.Invoke(ctx, "/protos.TLSCAA/RevokeCertificate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for TLSCAA service

type TLSCAAServer interface {
	RevokeCertificate(context.Context, *TLSCertRevokeReq) (*CAStatus, error)
}

func RegisterTLSCAAServer(s *grpc.Server, srv TLSCAAServer) {
	s.RegisterService(&_TLSCAA_serviceDesc, srv)
}

func _TLSCAA_RevokeCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(TLSCertRevokeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(TLSCAAServer).RevokeCertificate(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _TLSCAA_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.TLSCAA",
	HandlerType: (*TLSCAAServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RevokeCertificate",
			Handler:    _TLSCAA_RevokeCertificate_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}
